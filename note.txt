We need the ecall (Environment Call) instruction because it is the fundamental mechanism for crossing privilege boundaries in RISC-V. This is essential for the security and stability of the system, 
enabling two core functions: System Calls and Firmware Calls (SBI).

Here's a breakdown of why this mechanism is necessary:

1. Security and Isolation (Privilege Levels)

The RISC-V architecture defines multiple privilege levels to isolate different parts of the software. The key levels involved here are:
Level	Name	Purpose
M-mode	Machine Mode (Most Privileged)	Runs the firmware (like OpenSBI). It controls all hardware resources (clocks, interrupts, memory protection).
S-mode	Supervisor Mode	Runs the kernel (the operating system). It manages memory, processes, and provides a protected environment for applications.
U-mode	User Mode (Least Privileged)	Runs applications and user programs. It has limited access to system resources.

If the low-privileged code (like your kernel in S-mode) could directly access or modify critical hardware (like the clock or UART), a bug or malicious program could crash the entire system or compromise security.

The ecall instruction enforces this isolation:

    It acts as a controlled "gate" that forces the CPU to stop executing the low-privileged code and jump to a pre-defined, trusted handler in the higher-privileged code.

    This handler then validates the request and performs the operation on the caller's behalf.

2. Abstraction and Access to Resources

The ecall is used to implement two critical interfaces:

A. Firmware Calls (SBI)

Your example demonstrates this use. The kernel (S-mode) needs to perform an operation only the M-mode firmware (OpenSBI) is allowed to do, such as:

    Console I/O: Sending a character to the console (Console Putchar).

    Time Management: Setting a timer interrupt.

    Power Management: Entering a low-power state (wfi is often implemented this way or closely tied to the SBI).

The kernel uses ecall to execute the Supervisor Binary Interface (SBI). This abstracts the low-level, machine-specific hardware details away from the kernel, ensuring the kernel remains portable across different RISC-V platforms.

B. System Calls (Kernel Services)

While your code is using ecall for SBI, the same instruction is used by User Applications (U-mode) to request services from the Operating System Kernel (S-mode). For example, when a C program calls read() or fork(), it's compiled into an ecall instruction to switch from U-mode to S-mode.

In both cases (U-mode → S-mode, or S-mode → M-mode), the ecall is the only way to request services that require greater privilege.



The Function ID (FID), which is the value 0 in this specific call, is used to select a particular function within a specified Extension ID (EID) of the RISC-V Supervisor Binary Interface (SBI).

In your putchar call:


void putchar(char ch) { 
    sbi_call(ch, 0, 0, 0, 0, 0, 0, 1 /* Console Putchar */); 
    // Argument 7: FID (a6) is 0
    // Argument 8: EID (a7) is 1
}

Role of the Function ID (FID)

The SBI is structured hierarchically to allow for extensibility. The two-part ID system tells the OpenSBI firmware exactly what service is being requested:

    Extension ID (EID) → Service Category: The last argument, 1 (in register a7), selects the Base Extension. This tells the firmware, "The kernel wants to do a fundamental, basic operation."

    Function ID (FID) → Specific Function: The second-to-last argument, 0 (in register a6), specifies the exact function within that Base Extension.

FID (a6)	Function Name	Purpose
0	sbi_console_putchar	Outputs a single character. (This is the one being used.)
1	sbi_console_getchar	Reads a single character.
2	sbi_clear_ipi	Clears an Inter-Processor Interrupt.
...	...	(Other functions)

TIP(from the project link)

Life of Hello World:

When SBI is called, characters will be displayed as follows:

    The kernel executes ecall instruction. The CPU jumps to the M-mode trap handler (mtvec register), which is set by OpenSBI during startup.
    After saving registers, the trap handler written in C is called.
    Based on the eid, the corresponding SBI processing function is called.
    The device driver for the 8250 UART (Wikipedia) sends the character to QEMU.
    QEMU's 8250 UART emulation implementation receives the character and sends it to the standard output.
    The terminal emulator displays the character.

That is, by calling Console Putchar function is not a magic at all - it just uses the device driver implemented in OpenSBI!


why just the function signature for putchar is enough in common.c?
Ans:
Linker: After all files are compiled, the linker looks for the actual code (the definition) of putchar in all object files, 
finds it in the object file derived from kernel.c, and connects the call site in your printf code to the actual sbi_call logic.
(response from Gemini but seems correct)


Why is (void*)0 a valid expression in C ?
Ans: 
The C standard explicitly states a unique rule for the integer constant 0:

    An integer constant expression with the value 0, or such an expression cast to type void *, is called a null pointer constant.

This means that 0, when used in a pointer context (like assignment or a cast), is not treated as a normal integer value; 
it is guaranteed to be a valid constant that represents "no memory location".

Valid Syntax	Meaning
(void *)5	This is valid syntax. It casts the integer value 5 to a pointer type, creating a pointer that points to memory address 5. This is common in low-level programming (like your kernel/driver work) for accessing memory-mapped registers, but it should generally be avoided in application code.
(void *)0	This is the specific case that creates the null pointer constant.


The dangling else:

if (error_flag)
    {
        printf("PANIC: ...");
        while(1){}
    }; // <-- The semicolon following the macro
else // <-- ERROR: This 'else' is not attached to the previous 'if'
    printf("Success");

The compiler sees the block terminated by a semicolon, making the else a separate, unmatched token, which is a syntax error known as a dangling else.


/****** Important Note *************\
while your host machine uses its default compiler (GCC) and C library (glibc) to run programs like your web browser, 
the programs you write for your RISC-V emulator will be compiled by Clang and will need a separate RISC-V C library to run inside QEMU.



//Context switch test bug 

Starting process A AStarting process B BPANIC: kernel.c:290: unexpected trap scause=00000001, stval=00000000, sepc=00000000

Step by step:

    old_sp = &proc_a->sp → saves proc_b’s registers (current SP) into proc_a->sp

    proc_a stack is overwritten

    proc_b stack is not saved

    new_sp = &proc_b->sp → loads proc_b->sp (not saved yet properly)

    ret pops ra from proc_b stack → garbage, usually 0

    CPU jumps to 0x0 → trap occurs (scause=1, stval=0, sepc=0)

    This explains why your original code crashed at the first proc_b switch.
{
    printf("Starting process A\n");
    while(1)
    {
        putchar('A');
        switch_context(&proc_a->sp, &proc_b->sp);
        delay();
    }
}

void proc_b_entry(void)
{
    printf("Starting process B\n");
    while(1)
    {
        putchar('B');
       switch_context(&proc_a->sp, &proc_b->sp); //this caused the error
        delay();
    }
}

// old code for kernel_main
 // const char *s = "Hello World\n";
    // for(int i = 0; s[i] != '\0'; i++){
    //     putchar(s[i]);
    // }
    //memset(__bss, 0, (size_t)__bss_end - (size_t)__bss);

    //printf("\n\nHello %s\n", "World!");
    //printf("1 + 2 = %d, %x\n", 1+2, 0x1234abcd);

    //PANIC("booted!\n"); //from chapter 07: Kernel Panic 
    //printf("unreachable here!\n");

    //  memset(__bss, 0, (size_t)__bss_end - (size_t)__bss); //because dat in bss section is initialised to zero
    //  WRITE_CSR(stvec, (uint32_t)kernel_entry); //tell the CPU where the exception handler is located
    // /*
    //     This reads and writes the cycle register into x0. Since cycle is a read-only register, 
    //     CPU determines that the instruction is invalid and triggers an illegal instruction exception.
    // */
    // __asm__ __volatile__("unimp");            //unimp is a pseudo instruction. the assembler translates this to : csrrw x0,cycle,x0


    // //create an infinite idle loop
    // for(;;){
    //     __asm__ __volatile__("wfi"); // This is the Wait For Interrupt instruction, embedded via inline assembly. It is a power-saving mechanism
    // }

    //Chapter 9 : Memory Allocation Testing
    /*
    
        memset(__bss, 0, (size_t)__bss_end - (size_t)__bss); 

        paddr_t paddr0 = alloc_pages(2);
        paddr_t paddr1 = alloc_pages(1);
        printf("alloc_pages test: paddr0=%x\n", paddr0);
        printf("alloc_pages test: paddr1=%x\n", paddr1);

        PANIC("booted!");
    
    */
    
    //chapter 10: test for creation of two processes
    // memset(__bss, 0, (size_t) __bss_end - (size_t) __bss);
    // WRITE_CSR(stvec, (uint32_t) kernel_entry);

    // proc_a = create_process((uint32_t) proc_a_entry);
    // proc_b = create_process((uint32_t) proc_b_entry);
    // proc_a_entry(); //start the first process and trigger context switch

    // PANIC("unreachable here!");




    ## Excepion Handling
PANIC: kernel.c:291: unexpected trap scause=00000002, stval=00000000, sepc=80200370
value of scause = 2 means illegal instruction
```c

const char *s = "Hello World\n";
    for(int i = 0; s[i] != '\0'; i++){
        putchar(s[i]);
    }
    
     memset(__bss, 0, (size_t)__bss_end - (size_t)__bss); //because data in bss section is initialised to zero
     WRITE_CSR(stvec, (uint32_t)kernel_entry); //tell the CPU where the exception handler is located
    /*
        This reads and writes the cycle register into x0. Since cycle is a read-only register, 
        CPU determines that the instruction is invalid and triggers an illegal instruction exception.
    */
    __asm__ __volatile__("unimp");            //unimp is a pseudo instruction. the assembler translates this to : csrrw x0,cycle,x0

llvm-addr2line -e kernel.elf 80200370
/home/bhagyesh/myOS_project/kernel.c:313    //confirmed that this line matches with unimp instruction in kernel.c
```


### Testing our simple memory allocator
The kernel initializes the BSS section and then allocates the first blocks of physical memory using a simple bump allocator before panicking.

```c
void kernel_main(void) {
    // Zero out the entire BSS section
    memset(__bss, 0, (size_t) __bss_end - (size_t) __bss);

    // Allocate 2 pages (8KB) and 1 page (4KB)
    paddr_t paddr0 = alloc_pages(2);
    paddr_t paddr1 = alloc_pages(1);
    
    // Print the addresses of the allocated physical pages
    printf("alloc_pages test: paddr0=%x\n", paddr0);
    printf("alloc_pages test: paddr1=%x\n", paddr1);

    PANIC("booted!");
}

$ ./run.sh
alloc_pages test: paddr0=80221000
alloc_pages test: paddr1=80223000
PANIC: kernel.c:188: booted!


$ llvm-nm kernel.elf | grep __free_ram 
80221000 B __free_ram
84221000 B __free_ram_end

The symbol B means assigned to .bss section

```



```c
// Define a process object, also known as a Process Control Block (PCB)
struct process {
    int pid;                // Process ID
    int state;              // Process state: PROC_UNUSED or PROC_RUNNABLE
    vaddr_t sp;             // Stack Pointer
    uint8_t stack[8192];    // Kernel Stack
};
```
callee-saved registers - must be restored by the called function before returning.
In RISC-V, s0 - s11 are callee-saved registers. a0 and a1 are caller-saved registers
and are already saved on the stack by the caller


### Testing context switch
While testing context switching between `proc_a` and `proc_b`, I initially made the mistake of saving and restoring stacks incorrectly:

**Issue:** `switch_context(&proc_a->sp, &proc_b->sp)` was called, but `proc_b`’s stack was never properly initialized/saved.

**What happened:**
* `old_sp = &proc_a->sp` overwrote `proc_a`’s stack with the current SP (garbage)
* `new_sp = &proc_b->sp` loaded an uninitialized stack pointer
* `ret` popped a garbage return address $\to$ CPU jumped to `0x0`
* Kernel panic occurred (`scause=1`, `stval=0`, `sepc=0`)

It was fun to understand what happened in the background!
```c

```c

void proc_a_entry(void)
{
    printf("Starting process A\n");
    while(1)
    {
        putchar('A');
        switch_context(&proc_a->sp, &proc_b->sp);
        delay();
    }
}

void proc_b_entry(void)
{
    printf("Starting process B\n");
    while(1)
    {
        putchar('B');
        switch_context(&proc_b->sp, &proc_a->sp);
        delay();
    }
}

void kernel_main(void)
{
    memset(__bss, 0, (size_t) __bss_end - (size_t) __bss);
    WRITE_CSR(stvec, (uint32_t) kernel_entry);

    proc_a = create_process((uint32_t) proc_a_entry);
    proc_b = create_process((uint32_t) proc_b_entry);
    proc_a_entry(); //start the first process and trigger context switch

    PANIC("unreachable here!");

}

Output: 
Starting process A
AStarting process B
BABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABAB

```